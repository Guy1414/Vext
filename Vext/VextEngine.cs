using System.Diagnostics;
using Vext.Compiler.Bytecode_Generator;
using Vext.Compiler.Diagnostics;
using Vext.Compiler.Lexing;
using Vext.Compiler.Modules;
using Vext.Compiler.Parsing;
using Vext.Compiler.Semantic;
using Vext.Compiler.Shared;
using Vext.Compiler.VM;
using static Vext.Compiler.Diagnostics.Diagnostic;

namespace Vext.Compiler
{
    /// <summary>
    /// Results of a compilation process
    /// </summary>
    /// <param name="Code"></param>
    /// <param name="ParsedStatements"></param>
    /// <param name="Instructions"></param>
    /// <param name="Errors"></param>
    /// <param name="Tokens"></param>
    /// <param name="SemanticTokens"></param>
    /// <param name="VariableMap"></param>
    /// <param name="LexTime"></param>
    /// <param name="ParseTime"></param>
    /// <param name="SemanticTime"></param>
    /// <param name="BytecodeTime"></param>
    /// <param name="TokenCount"></param>
    /// <param name="NodeCount"></param>
    public record CompilationResult(
        string Code,
        List<StatementNode> ParsedStatements,
        List<Instruction> Instructions,
        List<ErrorDescriptor> Errors,
        List<Token> Tokens,
        List<SemanticToken> SemanticTokens,
        Dictionary<int, string> VariableMap,
        double LexTime, double ParseTime, double SemanticTime, double BytecodeTime,
        int TokenCount, int NodeCount
    );

    /// <summary>
    /// Represents the Vext Engine, responsible for compiling and running Vext code.
    /// </summary>
    public class VextEngine
    {
        /// <summary>
        /// Runs the compilation process on the provided Vext code.
        /// </summary>
        /// <param name="code">The Vext source code to compile.</param>
        /// <returns>A CompilationResult object containing the parsed AST, generated bytecode, detected errors, and other compilation artifacts.</returns>
        public static CompilationResult Compile(string code)
        {
            List<Instruction> instructions = [];
            var sw = new Stopwatch();

            // 1. Lexing
            sw.Restart();
            var lexer = new Lexing.Lexer(code);
            List<Token> tokens = lexer.Tokenize();
            double lexTime = sw.Elapsed.TotalMilliseconds;

            // 2. Parsing
            sw.Restart();
            var parser = new Parser(tokens);
            List<StatementNode> statements = parser.Parse();
            double parseTime = sw.Elapsed.TotalMilliseconds;

            // 3. Semantic Analysis
            sw.Restart();
            var semanticPass = new SemanticPass(statements);
            RegisterBuiltIns(semanticPass);
            semanticPass.Pass();
            double semTime = sw.Elapsed.TotalMilliseconds;
            Dictionary<int, string> varMap = semanticPass.GetVariableMap();

            if (Diagnostic.GetErrors().Count > 0)
                return new CompilationResult(code, statements, [], Diagnostic.GetErrors(), tokens, semanticPass.SemanticTokens, varMap, lexTime, parseTime, semTime, 0, tokens.Count, statements.Count);

            // 4. Bytecode Generation
            sw.Restart();
            foreach (StatementNode stmt in statements)
                BytecodeGenerator.EmitStatement(stmt, instructions);
            double bcTime = sw.Elapsed.TotalMilliseconds;

            return new CompilationResult(code, statements, instructions, Diagnostic.GetErrors(), tokens, semanticPass.SemanticTokens, varMap, lexTime, parseTime, semTime, bcTime, tokens.Count, statements.Count);
        }

        private static void RegisterBuiltIns(SemanticPass pass)
        {
            var math = new MathFunctions { Name = "Math" }.Initialize();
            foreach (var func in math.Functions.Values)
                pass.RegisterBuiltInFunctions(func);

            var defaults = new DefaultFunctions();
            defaults.Initialize();
            foreach (var func in defaults.Functions.Values)
                pass.RegisterBuiltInFunctions(func);
        }

        /// <summary>
        /// Runs the provided bytecode instructions in the Vext VM.
        /// </summary>
        /// <param name="instructions"></param>
        /// <returns></returns>
        public static (double Time, VextValue[] FinalState) Run(List<Instruction> instructions)
        {
            var sw = Stopwatch.StartNew();
            var mathModule = new MathFunctions { Name = "Math" }.Initialize();
            var defaults = new DefaultFunctions();
            defaults.Initialize();

            var vm = new VextVM(modulesList: [mathModule], defaults: defaults);
            int sp = 0;
            vm.Run(instructions, ref sp);
            sw.Stop();
            return (sw.Elapsed.TotalMilliseconds, vm.GetVariables());
        }
    }
}
