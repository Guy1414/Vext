using System.Diagnostics;

using Vext.Compiler.Bytecode_Generator;
using Vext.Compiler.Lexing;
using Vext.Compiler.Modules;
using Vext.Compiler.Parsing;
using Vext.Compiler.Semantic;
using Vext.Compiler.Shared;
using Vext.Compiler.VM;

using static Vext.Compiler.Diagnostics.Diagnostic;

namespace Vext.Compiler
{
    /// <summary>
    /// Results of a compilation process
    /// </summary>
    /// <param name="Code"></param>
    /// <param name="ParsedStatements"></param>
    /// <param name="Instructions"></param>
    /// <param name="Errors"></param>
    /// <param name="Tokens"></param>
    /// <param name="SemanticTokens"></param>
    /// <param name="VariableMap"></param>
    /// <param name="LexTime"></param>
    /// <param name="ParseTime"></param>
    /// <param name="SemanticTime"></param>
    /// <param name="BytecodeTime"></param>
    /// <param name="TokenCount"></param>
    /// <param name="NodeCount"></param>
    public record CompilationResult(
        string Code,
        List<StatementNode> ParsedStatements,
        List<Instruction> Instructions,
        List<ErrorDescriptor> Errors,
        List<Token> Tokens,
        List<SemanticToken> SemanticTokens,
        Dictionary<int, string> VariableMap,
        double LexTime, double ParseTime, double SemanticTime, double BytecodeTime,
        int TokenCount, int NodeCount
    );

    /// <summary>
    /// Represents the Vext Engine, responsible for compiling and running Vext code.
    /// </summary>
    public class VextEngine
    {
        /// <summary>
        /// Runs the compilation process on the provided Vext code.
        /// </summary>
        /// <param name="code">The Vext source code to compile.</param>
        /// <returns>A CompilationResult object containing the parsed AST, generated bytecode, detected errors, and other compilation artifacts.</returns>
        public static CompilationResult Compile(string code)
        {
            // Clear diagnostics from previous compilations
            Clear();

            List<Instruction> instructions = [];
            Stopwatch sw = new Stopwatch();

            // 1. Lexing
            sw.Restart();
            Lexer lexer = new Lexer(code);
            List<Token> tokens = lexer.Tokenize();
            double lexTime = sw.Elapsed.TotalMilliseconds;

            // 2. Parsing
            sw.Restart();
            Parser parser = new Parser(tokens);
            List<StatementNode> statements = parser.Parse();
            double parseTime = sw.Elapsed.TotalMilliseconds;

            // 3. Semantic Analysis
            sw.Restart();
            SemanticPass semanticPass = new SemanticPass(statements);
            RegisterBuiltIns(semanticPass);
            semanticPass.Pass();
            double semTime = sw.Elapsed.TotalMilliseconds;
            Dictionary<int, string> varMap = semanticPass.GetVariableMap();

            if (GetErrors().Count > 0)
                return new CompilationResult(
                    code,
                    statements,
                    [],
                    GetErrors(),
                    tokens,
                    semanticPass.SemanticTokens,
                    varMap,
                    lexTime,
                    parseTime,
                    semTime,
                    0,
                    tokens.Count,
                    statements.Count
                );

            // 4. Bytecode Generation
            sw.Restart();
            foreach (StatementNode stmt in statements)
                BytecodeGenerator.EmitStatement(stmt, instructions);
            double bcTime = sw.Elapsed.TotalMilliseconds;

            return new CompilationResult(
                code,
                statements,
                instructions,
                GetErrors(),
                tokens,
                semanticPass.SemanticTokens,
                varMap,
                lexTime,
                parseTime,
                semTime,
                bcTime,
                tokens.Count,
                statements.Count
            );
        }

        /// <summary>
        /// Runs the provided bytecode instructions in the Vext VM.
        /// </summary>
        /// <param name="instructions"></param>
        /// <returns></returns>
        public static (double Time, VextValue[] FinalState, string Stdout) Run(List<Instruction> instructions)
        {
            Stopwatch sw = Stopwatch.StartNew();

            RuntimeOutput output = new RuntimeOutput();

            Module mathModule = new MathFunctions { Name = "Math" }.Initialize();
            DefaultFunctions defaults = new DefaultFunctions(output);
            defaults.Initialize();

            VextVM vm = new VextVM(
                modulesList: [mathModule],
                defaults: defaults
            );

            int sp = 0;
            vm.Run(instructions, ref sp);

            string stdout = output.Flush();

            sw.Stop();
            return (sw.Elapsed.TotalMilliseconds, vm.GetVariables(), stdout);
        }

        private static void RegisterBuiltIns(SemanticPass pass)
        {
            Module math = new MathFunctions { Name = "Math" }.Initialize();
            foreach (List<Function> func in math.Functions.Values)
                pass.RegisterBuiltInFunctions(func, math.Name);

            RuntimeOutput dummyOutput = new RuntimeOutput();
            DefaultFunctions defaults = new DefaultFunctions(dummyOutput);
            defaults.Initialize();

            foreach (List<Function> func in defaults.Functions.Values)
                pass.RegisterBuiltInFunctions(func);
        }
    }
}
